{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Hidrospetiva Docs to StreamWater Project Tasks Set up development environment Consume sensor API Update documentation Commands pytho version - Check python version. python -m venv venv - Create a virtual environment. source venv/bin/activate - Activate virtual enviroment. pip install httpx - Install the library to make a request to the API. Project layout venv # The virtual environment file. main/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Code to interact with the API import httpx from datetime import datetime, timedelta class SyncAPIClient: def __init__(self, auth_url, api_url, timeout=10.0): self.auth_url = auth_url self.api_url = api_url self.token = None self.token_expiry = None self.timeout = timeout self.client = httpx.Client(timeout=timeout) def __del__(self): \"\"\"Ensures that the client is closed when the object is destroyed\"\"\" self.client.close() def get_token(self, client_id, client_secret): \"\"\"Gets an authentication token from the API synchronously\"\"\" # Check if we already have a valid token if self.token and self.token_expiry and datetime.now() < self.token_expiry: return self.token # Prepare authentication data auth_data = { 'client_id': client_id, 'client_secret': client_secret, 'grant_type': 'client_credentials' } try: # Make the request to get the token response = self.client.post(self.auth_url, data=auth_data) response.raise_for_status() # Extract the token and its validity from the response token_info = response.json() self.token = token_info.get('access_token') expires_in = token_info.get('expires_in', 3600) # Default to 1 hour # Calculate when the token expires self.token_expiry = datetime.now() + timedelta(seconds=expires_in) return self.token except httpx.HTTPError as e: print(f\"Error getting token: {e}\") raise def get_api_data(self, endpoint, params=None, client_id=None, client_secret=None): \"\"\"Makes a GET call to the API using the Bearer token synchronously\"\"\" # Make sure we have a valid token token = self.get_token(client_id, client_secret) # Prepare headers with the Bearer token headers = { 'Authorization': f'Bearer {token}', 'Accept': 'application/json' } try: # Make the GET request to the API response = self.client.get( f\"{self.api_url}/{endpoint}\", headers=headers, params=params # Query string parameters ) response.raise_for_status() return response.json() except httpx.HTTPError as e: print(f\"Error in API call: {e}\") raise # Main function that exemplifies usage def main(): # API Configuration AUTH_URL = \"https://api.example.com/oauth/token\" API_URL = \"https://api.example.com/v1\" CLIENT_ID = \"your_client_id\" CLIENT_SECRET = \"your_client_secret\" # Initialize the API client api_client = SyncAPIClient(AUTH_URL, API_URL) # Parameters for the GET query (optional) params = { \"limit\": 10, \"sort\": \"created_at\" } # Make the GET call to the API try: result = api_client.get_api_data( \"users\", params=params, client_id=CLIENT_ID, client_secret=CLIENT_SECRET ) print(\"Data obtained from API:\", result) # Example of how to make several sequential GET calls endpoints = [\"users\", \"products\", \"categories\"] results = [] for endpoint in endpoints: try: result = api_client.get_api_data( endpoint, params=params, client_id=CLIENT_ID, client_secret=CLIENT_SECRET ) results.append(result) print(f\"Data obtained from {endpoint}: {len(result)} items\") except Exception as e: print(f\"Error getting data from {endpoint}: {e}\") except Exception as e: print(f\"Operation failure: {e}\") finally: # Ensure the HTTP client is closed api_client.client.close() # Script entry point if __name__ == \"__main__\": # Execute the main function main()","title":"Welcome to Hidrospetiva Docs to StreamWater Project"},{"location":"#welcome-to-hidrospetiva-docs-to-streamwater-project","text":"","title":"Welcome to Hidrospetiva Docs to StreamWater Project"},{"location":"#tasks","text":"Set up development environment Consume sensor API Update documentation","title":"Tasks"},{"location":"#commands","text":"pytho version - Check python version. python -m venv venv - Create a virtual environment. source venv/bin/activate - Activate virtual enviroment. pip install httpx - Install the library to make a request to the API.","title":"Commands"},{"location":"#project-layout","text":"venv # The virtual environment file. main/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"#code-to-interact-with-the-api","text":"import httpx from datetime import datetime, timedelta class SyncAPIClient: def __init__(self, auth_url, api_url, timeout=10.0): self.auth_url = auth_url self.api_url = api_url self.token = None self.token_expiry = None self.timeout = timeout self.client = httpx.Client(timeout=timeout) def __del__(self): \"\"\"Ensures that the client is closed when the object is destroyed\"\"\" self.client.close() def get_token(self, client_id, client_secret): \"\"\"Gets an authentication token from the API synchronously\"\"\" # Check if we already have a valid token if self.token and self.token_expiry and datetime.now() < self.token_expiry: return self.token # Prepare authentication data auth_data = { 'client_id': client_id, 'client_secret': client_secret, 'grant_type': 'client_credentials' } try: # Make the request to get the token response = self.client.post(self.auth_url, data=auth_data) response.raise_for_status() # Extract the token and its validity from the response token_info = response.json() self.token = token_info.get('access_token') expires_in = token_info.get('expires_in', 3600) # Default to 1 hour # Calculate when the token expires self.token_expiry = datetime.now() + timedelta(seconds=expires_in) return self.token except httpx.HTTPError as e: print(f\"Error getting token: {e}\") raise def get_api_data(self, endpoint, params=None, client_id=None, client_secret=None): \"\"\"Makes a GET call to the API using the Bearer token synchronously\"\"\" # Make sure we have a valid token token = self.get_token(client_id, client_secret) # Prepare headers with the Bearer token headers = { 'Authorization': f'Bearer {token}', 'Accept': 'application/json' } try: # Make the GET request to the API response = self.client.get( f\"{self.api_url}/{endpoint}\", headers=headers, params=params # Query string parameters ) response.raise_for_status() return response.json() except httpx.HTTPError as e: print(f\"Error in API call: {e}\") raise # Main function that exemplifies usage def main(): # API Configuration AUTH_URL = \"https://api.example.com/oauth/token\" API_URL = \"https://api.example.com/v1\" CLIENT_ID = \"your_client_id\" CLIENT_SECRET = \"your_client_secret\" # Initialize the API client api_client = SyncAPIClient(AUTH_URL, API_URL) # Parameters for the GET query (optional) params = { \"limit\": 10, \"sort\": \"created_at\" } # Make the GET call to the API try: result = api_client.get_api_data( \"users\", params=params, client_id=CLIENT_ID, client_secret=CLIENT_SECRET ) print(\"Data obtained from API:\", result) # Example of how to make several sequential GET calls endpoints = [\"users\", \"products\", \"categories\"] results = [] for endpoint in endpoints: try: result = api_client.get_api_data( endpoint, params=params, client_id=CLIENT_ID, client_secret=CLIENT_SECRET ) results.append(result) print(f\"Data obtained from {endpoint}: {len(result)} items\") except Exception as e: print(f\"Error getting data from {endpoint}: {e}\") except Exception as e: print(f\"Operation failure: {e}\") finally: # Ensure the HTTP client is closed api_client.client.close() # Script entry point if __name__ == \"__main__\": # Execute the main function main()","title":"Code to interact with the API"}]}